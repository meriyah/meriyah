import * as t from 'node:assert/strict';
import { outdent } from 'outdent';
import { describe, it } from 'vitest';
import { parseSource } from '../../../src/parser';
import { fail, pass } from '../../test-utils';

describe('Expressions - New', () => {
  for (const arg of [
    'new x(1);',
    'new x;',
    'new new x;',
    'new new x.y;',
    'new (function(foo){this.foo=foo;})(1);',
    'new (function(foo){this.foo=foo;})();',
    'new (function test(foo){this.foo=foo;})(1);',
    'new (function test(foo){this.foo=foo;})();',
    'new true;',
    'new (0);',
    'new (!0);',
    'new (bar = function(foo) {this.foo=foo;})(123);',
    'new (bar = function(foo) {this.foo=foo;})();',
    'new x(1);',
    'new x();',
    'new x();',
    'new x()()()()()()();',
    'new (x()()()()()()());',
    'new new x()();',
    'new function(foo) {\n    this.foo = foo;\n}(1);',
    'new function(foo) {\n    this.foo = foo;\n}();',
    'new function test(foo) {\n    this.foo = foo;\n}(1);',
    'new function test(foo) {\n    this.foo = foo;\n}();',
    'new true();',
    'new async()()',
    'new a()().b.c[d];',
    'new async()().b.c[d];',
    'new (a()().b.c[d]);',
    'new (b());',
    'new (async(await));',
    'new async / b',
    'new async / await',
    'new async / await()',
    'new async / await(async = foo)',
    'new async / await(async,)',
    'new async / await(foo, async)',
    'new async / await("foo", async)',
    'new async / await(123, async)',
    'new async / await(foo, async)',
    'new 0();',
    'new (!0)();',
    'new (bar = function(foo) {\n    this.foo = foo;\n})(123);',
    'new (bar = function(foo) {\n    this.foo = foo;\n})();',
  ]) {
    it(`${arg}`, () => {
      t.doesNotThrow(() => {
        parseSource(`${arg}`, { webcompat: true });
      });
    });
    it(`${arg}`, () => {
      t.doesNotThrow(() => {
        parseSource(`${arg}`);
      });
    });
  }
  fail('Expressions - New (fail)', [
    'function f(){ new.foo }',
    'new.target',
    '_ => new.target',
    'function f(){ ++new.target }',
    'function f(){ new.target-- }',
    '(f=new.target) => {}',
    'new x() = y',
    'new a.b.c.(d).e.f.g[(b)]();',
    'new a.async.c.(d).e.f.g[(async)]();',
    'new async = async.await',
    '++new x()',
    'new x()++',
    'new new .target',
    'new typeof x',
    'new typeof x.y',
    'new typeof x().y',
    'new ++x',
    'new ++x.y',
    'new ++x().y',
    'new ()=>{}',
    'new x=>{}',
    'new (x)=>{}',
    'new a = b',
    'function *f(){ new yield }',
    '"use strict"; new yield()',
    'function *f(){ new yield }',
    'function *f(){ new yield x }',
    'function *f(){ new yield x(); }',
    'new x++',
    'new x.y++',
    outdent`
      function f() {
        new.target++;
        new.target = b;
        for (new.target in b);
        for (new.target of b);
      }
    `,
    'new async x => x',
    'new async => x',
    'let x = typeof async (x) => x',
    'let x = [typeof async \n (x) => x]',
    'let x = [typeof async (x) \n => x]',
    'let x = [delete async \n (x) => x]',
    'let x = [delete async (x) \n => x]',
    'new x\n/y/',
    'let x = new async \n (x) => x',
    'let x = new async (x) \n => x',
    'typeof async () => x',
    'typeof async \n () => x',
    'typeof async () \n => x',
    'let x = typeof async \n (x) => x',
    'let x = typeof async (x) \n => x',
    'delete async () => x',
    'delete async \n () => x',
    'delete async () \n => x',
    'new ++x.y',
    'let x = delete async \n (x) => x',
    'let x = delete async (x) \n => x',
    'async () => new await x',
    'async () => new await x()',
    'async () => new await x()()',
    'async function f(){ new await foo }',
    'new class',
    'new class extends{}',
    'new delete',
    'new function',
    'new function()',
    'new new',
    'new super',
    'class x { constructor() { new super }}',
    'class x extends y { constructor() { new super }}',
    'new typeof',
    'new typeof x',
    'new typeof x()',
    'new void',
    'new void x',
    'delete () => foo',
    'delete async() => foo',
    'function f(){ new.foo }',
    'new.target',
    '_ => _ => _ => _ => new.target',
    'function f(){ ++new.target }',
    'function f(){ new.target-- }',
    'new x(await foo);',
    'new (await foo);',
    'new await foo;',
    'new x(await foo);',
    'new x(await foo);',
    'new x(await foo);',
    'new.target[await x]',
    'new await x()()',
    'new await x()',
    'new await x',
  ]);

  pass('Expressions - New (pass)', [
    'new await()()',
    'new foo()();',
    'new (foo)();',
    'new (foo);',
    'new a ? b : c',
    'new Foo',
    'new Foo.Bar',
    'new a.b.c.d',
    'new async(x)(y)',
    'new Foo["bar"]',
    'new Foo()',
    'new Foo.Bar()',
    'new Foo["bar"]()',
    'new Foo(X)',
    'new Foo.Bar(X)',
    'new Foo["bar"](X)',
    'new Foo(X, Y, Z)',
    'new Foo.Bar(X, Y, Z)',
    'new Foo["bar"](X, Y, Z)',
    'new x().y',
    'new x()[y]',
    'new x()();',
    //['new x()`y`', Context.None,  {}],
    'new a.b.c.d()',
    'new Foo["bar"]()',
    'new Foo(X)',
    'new Foo.Bar(X)',
    'new Foo["bar"](X)',
    'new Foo(X, Y, Z)',
    'new Foo.Bar(X, Y, Z)',
    'new Foo["bar"](X, Y, Z)',
    'new x().y',
    'new x()[y]',
    'new x()();',
    'new x().y = z',
    'new x().y + z',
    'new x()[y] = z',
    'new x()[y] + z',
    '++new x().y',

    'new x().y++',
    'delete new x()',
    'delete new x().y',
    'typeof new x()',
    'new new A().foo',
    'new new A.foo()',
    'new "foo".__proto__.constructor',
    'new 1..__proto__.constructor',
    'new 0x2.__proto__.constructor',
    'new true.__proto__.constructor',
    'typeof new x().y',
    'new new x',

    '[...new A()]',
    'class x extends new A() {}',
    'x({[new A()]:y})',
    'f(new /z/())',
    'f(new /z/)',
    'f(new /z/.foo)',
    'new arguments',
    'new async',
    'new async (x, y)',
    'new async (...x)',
    'new async function(){}',
    'typeof async',
    'typeof async ()',
    'typeof async function(){}',
    'new await',
    'new class{}',
    'new class extends x{}',
    'class x extends (x) {}',
    'new eval()',
    'new false.__proto__.constructor',
    'new function(){}',
    'new function(){}(x)',
    'class x extends y { constructor() { new super.foo }}',
    'class x extends y { constructor() { new super() }}',
    'new this',
    'new let',
  ]);
});
